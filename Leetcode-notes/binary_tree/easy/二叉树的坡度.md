# 题目 - 二叉树的坡度

## 题目描述

给定一个二叉树，计算整个树的坡度 。

一个树的节点的坡度定义即为，该节点左子树的节点之和和右子树节点之和的差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。

整个树的坡度就是其所有节点的坡度之和。

* 二叉树节点定义如下：
```java
public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
}
```

提示：
* 树中节点数目的范围在 [0, 10^4] 内
* -1000 <= Node.val <= 1000

## 题解

### 我的思路1

做一个双重的dfs，第一层dfs计算各个节点的坡度各自是多少，第二层计算已经由第一层dfs得出的各个节点的坡度总和
* 缺点是这两层的遍历实际上会进行很多重复的计算
```java
class Solution {
    public int findTilt(TreeNode root) {
        if(root == null) return 0;
        return Math.abs(calculateSum(root.left) - calculateSum(root.right)) + findTilt(root.left) + findTilt(root.right);
    }

    public int calculateSum(TreeNode node){
        if(node == null) return 0;
        return calculateSum(node.left) + calculateSum(node.right) + node.val;
    }
}
```

### 我的思路2

对于一个节点`ndoe`来说
* 其坡度等于左子树之和和右子树之和的差值的绝对值: 
  * `|sum(node.left) - sum(node.right)|`
* 同时，在遍历的过程中，为了计算`node`的父节点的坡度，也需要将以`node`为根节点的这颗子树的和返回给父节点： 
  * `sum(node.left) + sum(node.right)`

这也就意味着在同一个递归中，实际上可以同时计算坡度和子树和，因为都会用到`sum(node.left)`和`sum(node.right)`，因此我只使用一次递归，并让递归不返回子树和，而是返回一个包含子树和还有对应子树中所有节点的坡度和的数组：
```java
class Solution {
    public int findTilt(TreeNode root) {
        return calculate(root)[1];
    }

    public int[] calculate(TreeNode node){
        if(node == null) return new int[]{0,0};
        int[] resultLeft = calculate(node.left);
        int[] resultRight = calculate(node.right);
        return new int[]{
            resultLeft[0] + resultRight[0] + node.val,
            Math.abs(resultLeft[0] - resultRight[0]) + resultLeft[1] + resultRight[1]
        };
    }
}
```

### 最终优化

通过直接使用类成员变量`sum`的方式，避免了在递归中不断创建新的`int[]`数组，这样递归函数只需要返回子树之和，在返回之前直接将坡度和累加到`sum`成员变量中
```java
class Solution {
    int sum = 0;
    
    public int findTilt(TreeNode root) {
        calculate(root);
        return sum;
    }

    public int calculate(TreeNode node){
        if(node == null) return 0;
        int resultLeft = calculate(node.left);
        int resultRight = calculate(node.right);
        sum += Math.abs(resultLeft - resultRight);
        return resultLeft + resultRight + node.val;
    }
}
```
